This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2024-12-29T01:43:29.254Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repomix, visit: https://github.com/yamadashy/repomix

================================================================
Repository Structure
================================================================
.env.template
.gitignore
LICENSE
README.md
render.yaml
requirements.txt
src/app.py
src/config.py
src/services/api_service.py
src/services/display.py
src/utils/__init__.py
src/utils/formatters.py
src/utils/validators.py
tests/test_display.py

================================================================
Repository Files
================================================================

================
File: .env.template
================
# Server Configuration
PORT=8080
HOST=0.0.0.0
DEBUG=False

# Plugin Configuration
REFRESH_INTERVAL=3600  # 1 hour in seconds

# TRMNL Configuration
TRMNL_API_KEY=your_trmnl_api_key_here
TRMNL_PLUGIN_UUID=your_plugin_uuid_here

# Display Configuration
DISPLAY_WIDTH=800
DISPLAY_HEIGHT=480

# Cache Configuration
CACHE_TIMEOUT=3600  # Should match REFRESH_INTERVAL

================
File: .gitignore
================
# Project-specific files
.env
api_test.py

# Python
__pycache__/
*.py[cod]
*.class
.Python
env/
venv/
build/
dist/
*.egg-info/

# IDE
.idea/
.vscode/
*.swp

# OS
.DS_Store
Thumbs.db

# Logs
*.log
logs/

# Testing
.coverage
htmlcov/
.pytest_cache/

================
File: LICENSE
================
MIT License

Copyright (c) 2024 OptimumMeans

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

================
File: README.md
================
# TRMNL Plugin Boilerplate

A boilerplate template for creating TRMNL e-ink display plugins.

## Features

- Flask-based webhook endpoint with CORS support
- E-ink display optimization
- Built-in caching system
- Comprehensive error handling
- Structured logging
- Environment-based configuration management
- Display generator service with error display support
- API service template with caching
- Extensive utility functions for formatting and validation

## Prerequisites

- Python 3.12+
- TRMNL device and API key
- Docker (optional)

## Installation

1. Clone the repository:
```bash
git clone https://github.com/yourusername/your-plugin.git
cd your-plugin
```

2. Create and activate a virtual environment:
```bash
python -m venv venv
source venv/bin/activate  # On Windows: venv\Scripts\activate
```

3. Install dependencies:
```bash
pip install -r requirements.txt
```

4. Create .env file:
```bash
cp .env.template .env
```

5. Update .env with your configuration:
```
TRMNL_API_KEY=your_api_key_here
TRMNL_PLUGIN_UUID=your_plugin_uuid_here
```

## Development

### Running Locally

```bash
python -m src.app
```

The development server will automatically open your default browser to the webhook endpoint. You can access:
- Home page: http://localhost:8080/
- Webhook endpoint: http://localhost:8080/webhook

### Project Structure
```
├── .env.template         # Environment variables template
├── .gitignore           # Git ignore rules
├── README.md            # Project documentation
├── render.yaml          # Render deployment configuration
├── requirements.txt     # Python dependencies
├── src/                 # Source code directory
│   ├── app.py          # Main application entry point
│   ├── config.py       # Configuration management
│   ├── services/       # Core services
│   │   ├── api_service.py    # API interaction service
│   │   └── display.py        # Display generation service
│   └── utils/          # Utility functions
│       ├── __init__.py      # Package exports
│       ├── formatters.py    # Data formatting utilities
│       └── validators.py    # Data validation utilities
└── tests/              # Test files
    └── test_display.py  # Display service tests
```

### Core Components

1. **API Service** (`src/services/api_service.py`)
   - Handles all API interactions
   - Implements caching mechanism
   - Tracks last update timestamp

2. **Display Generator** (`src/services/display.py`)
   - Creates optimized images for e-ink display
   - Handles error displays
   - Supports status bar and content layout

3. **Utility Functions**
   - `formatters.py`: Date/time formatting, API response formatting
   - `validators.py`: Data validation, string sanitization
   - Common utilities exported through `__init__.py`

4. **Configuration** (`src/config.py`)
   - Environment-based configuration
   - Validation for required settings
   - Default values for optional settings

### Creating Your Plugin

1. Modify `src/services/api_service.py` to implement your data fetching logic
2. Update `src/services/display.py` to customize the display layout
3. Add any additional utilities in `src/utils/`
4. Update configuration in `src/config.py` as needed

## Testing

Run the test suite:

```bash
python -m pytest tests/
```

Current test coverage includes:
- Display generator initialization
- Error display generation
- API service functionality
- Display creation with mock data

## Deployment

Deploy using render.yaml configuration:

```bash
render deploy
```

The render.yaml file includes:
- Python 3.12.0 runtime
- Gunicorn web server
- Environment variable configuration
- Build and start commands

## Contributing

1. Fork the repository
2. Create your feature branch
3. Commit your changes
4. Push to the branch
5. Create a Pull Request

## License

MIT

================
File: render.yaml
================
services:
  - type: web
    name: trmnl-plugin
    env: python
    buildCommand: pip install -r requirements.txt
    startCommand: gunicorn src.app:app
    envVars:
      - key: PYTHON_VERSION
        value: 3.12.0
      - key: PORT
        value: 8080
      - key: TRMNL_API_KEY
        sync: false
      - key: TRMNL_PLUGIN_UUID
        sync: false

================
File: requirements.txt
================
flask==3.0.0
pillow==10.1.0
requests==2.31.0
python-dotenv==1.0.0
gunicorn==21.2.0
pytz==2024.1
pymemcache==4.0.0
python-dateutil==2.8.2
flask-cors==4.0.0

================
File: src/app.py
================
from flask import Flask, Response, jsonify
from flask_cors import CORS
import logging
from datetime import datetime, UTC
import traceback
import os
import webbrowser
from threading import Timer

from .config import Config
from .services.display import DisplayGenerator
from .services.api_service import APIService
from .utils.formatters import format_timestamp

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

# Initialize Flask app
app = Flask(__name__)
CORS(app)

# Initialize services
api_service = APIService()
display_generator = DisplayGenerator(Config.DISPLAY_WIDTH, Config.DISPLAY_HEIGHT)

def open_browser():
    webbrowser.open('http://localhost:8080/webhook')

@app.route('/')
def home():
    return jsonify({
        'name': 'TRMNL Plugin',
        'description': 'TRMNL Plugin Boilerplate',
        'version': '1.0.0',
        'status': 'running',
        'last_update': api_service.last_update.isoformat() if api_service.last_update else None,
        'refresh_interval': Config.REFRESH_INTERVAL
    })

@app.route('/webhook', methods=['GET'])
def trmnl_webhook():
    try:
        data = api_service.get_data()
        logger.info(f'Data retrieved: {data}')
        
        image_data = display_generator.create_display(data)
        
        return Response(
            image_data,
            mimetype='image/bmp',
            headers={
                'X-TRMNL-Refresh': str(Config.REFRESH_INTERVAL),
                'X-TRMNL-Plugin-UUID': Config.TRMNL_PLUGIN_UUID
            }
        )
        
    except Exception as e:
        logger.error(f'Webhook error: {str(e)}')
        logger.error(traceback.format_exc())
        return Response(
            display_generator.create_error_display(str(e)),
            mimetype='image/bmp'
        )

if __name__ == '__main__':
    print('=' * 80)
    print('TRMNL Plugin Development Server')
    print('=' * 80)
    print(f'Server URL: http://localhost:{Config.PORT}')
    print(f'Webhook URL: http://localhost:{Config.PORT}/webhook')
    print('-' * 80)
    print('Opening webhook URL in browser...')
    print('Press Ctrl+C to quit')
    print('=' * 80)
    
    # Open browser after a short delay
    Timer(1.5, open_browser).start()
    
    app.run(
        host=Config.HOST,
        port=Config.PORT,
        debug=Config.DEBUG
    )

================
File: src/config.py
================
import os
from dotenv import load_dotenv

# Load environment variables
load_dotenv()

class Config:
    
    # Server Configuration
    HOST = os.getenv('HOST', '0.0.0.0')
    PORT = int(os.getenv('PORT', 8080))
    DEBUG = os.getenv('DEBUG', 'False').lower() == 'true'
    
    # Plugin Configuration
    REFRESH_INTERVAL = int(os.getenv('REFRESH_INTERVAL', '3600'))  # Default 1 hour
    
    # TRMNL Configuration
    TRMNL_API_KEY = os.getenv('TRMNL_API_KEY')
    TRMNL_PLUGIN_UUID = os.getenv('TRMNL_PLUGIN_UUID')
    
    # Display Configuration
    DISPLAY_WIDTH = int(os.getenv('DISPLAY_WIDTH', '800'))
    DISPLAY_HEIGHT = int(os.getenv('DISPLAY_HEIGHT', '480'))
    
    # Cache Configuration
    CACHE_TIMEOUT = int(os.getenv('CACHE_TIMEOUT', '3600'))  # Cache timeout matches refresh
    
    @classmethod
    def validate(cls):
        required_keys = [
            'TRMNL_API_KEY',
            'TRMNL_PLUGIN_UUID'
        ]
        
        missing_keys = [key for key in required_keys if not getattr(cls, key)]
        
        if missing_keys:
            raise ValueError(
                f"Missing required configuration: {', '.join(missing_keys)}"
            )

================
File: src/services/api_service.py
================
from datetime import datetime, UTC
import logging
from typing import Optional, Dict, Any
import requests
from ..config import Config

logger = logging.getLogger(__name__)

class APIService:
    
    CHUCK_NORRIS_API = "https://api.chucknorris.io/jokes/random"
    
    def __init__(self):
        self.last_update = None
        self._cached_data = None
        self._cache_timestamp = None
    
    def get_data(self) -> Optional[Dict[str, Any]]:
        '''Get data from the Chuck Norris API.'''
        try:
            if self._is_cache_valid():
                return self._cached_data
            
            data = self._fetch_data()
            
            self._update_cache(data)
            self.last_update = datetime.now(UTC)
            
            return data
            
        except Exception as e:
            logger.error(f"Error fetching Chuck Norris fact: {str(e)}")
            return None
    
    def _fetch_data(self) -> Dict[str, Any]:
        '''Fetch a random Chuck Norris fact.'''
        response = requests.get(self.CHUCK_NORRIS_API)
        response.raise_for_status()
        
        joke_data = response.json()
        
        return {
            'timestamp': datetime.now(UTC).isoformat(),
            'status': 'ok',
            'fact': joke_data['value'],
            'icon_url': joke_data['icon_url'],
            'fact_id': joke_data['id']
        }
    
    def _update_cache(self, data: Dict[str, Any]) -> None:
        self._cached_data = data
        self._cache_timestamp = datetime.now(UTC)
    
    def _is_cache_valid(self) -> bool:
        if not self._cache_timestamp:
            return False
            
        cache_age = (datetime.now(UTC) - self._cache_timestamp).total_seconds()
        return cache_age < Config.CACHE_TIMEOUT

================
File: src/services/display.py
================
from PIL import Image, ImageDraw, ImageFont, ImageOps
import io
import logging
from datetime import datetime
from typing import Dict, Any, Optional
import textwrap
import requests
from io import BytesIO

logger = logging.getLogger(__name__)

class DisplayGenerator:
    def __init__(self, width: int, height: int):
        self.width = width
        self.height = height
        self.CHUCK_IMAGE_URL = "https://i.seadn.io/gae/MD2INKicV62FvEbGiNKyMdoRkDguSxL9JkCkGjgyJT0IzFe4VpNb-5nqWCvzpObAQHOkpjp8mmGL00cGLEkQx4ZC-8JrmlRBDth5Sg?auto=format&dpr=1&w=1000"
        self.cached_chuck_image = None
        
        try:
            # Main display fonts
            self.title_font = ImageFont.truetype(font='arial.ttf', size=48)
            self.fact_font = ImageFont.truetype(font='arial.ttf', size=32)
            self.meta_font = ImageFont.truetype(font='arial.ttf', size=16)
        except Exception as e:
            logger.warning(f'Failed to load TrueType font: {e}')
            self.title_font = ImageFont.load_default()
            self.fact_font = ImageFont.load_default()
            self.meta_font = ImageFont.load_default()
        
        # Pre-load and process Chuck Norris image
        self._load_chuck_image()

    def _load_chuck_image(self):
        """Load and process Chuck Norris image"""
        try:
            # Download image
            response = requests.get(self.CHUCK_IMAGE_URL)
            image = Image.open(BytesIO(response.content))
            
            # Convert to grayscale
            image = image.convert('L')
            
            # Resize to appropriate height (maintain aspect ratio)
            target_height = 120
            aspect_ratio = image.width / image.height
            target_width = int(target_height * aspect_ratio)
            image = image.resize((target_width, target_height), Image.Resampling.LANCZOS)
            
            # Apply dithering
            image = image.convert('1', dither=Image.Dither.FLOYDSTEINBERG)
            
            self.cached_chuck_image = image
            logger.info("Successfully loaded and processed Chuck Norris image")
            
        except Exception as e:
            logger.error(f"Failed to load Chuck Norris image: {str(e)}")
            self.cached_chuck_image = None

    def create_display(self, data: Dict[str, Any]) -> Optional[bytes]:
        try:
            image = Image.new('1', (self.width, self.height), 1)  # 1 = white background
            draw = ImageDraw.Draw(image)
            
            if not data or 'fact' not in data:
                return self.create_error_display('No Chuck Norris fact available')
            
            # Draw content
            self._draw_header_with_image(draw, image)
            self._draw_fact(draw, data)
            self._draw_footer(draw, data)
            
            buffer = io.BytesIO()
            image.save(buffer, format='BMP')
            return buffer.getvalue()
            
        except Exception as e:
            logger.error(f'Error generating display: {str(e)}')
            return self.create_error_display(str(e))

    def _draw_header_with_image(self, draw: ImageDraw, base_image: Image):
        """Draw the header section with Chuck Norris image"""
        if self.cached_chuck_image:
            # Calculate image position (left side)
            image_y = 20
            base_image.paste(self.cached_chuck_image, (20, image_y))
            
            # Draw title to the right of the image
            title_text = "Chuck Norris Fact"
            x = 200  # Position after image
            y = 60
            
            draw.text((x, y), title_text, font=self.title_font, fill=0)
            
            # Draw line under the header area
            line_y = image_y + self.cached_chuck_image.height + 20
            draw.line([(20, line_y), (self.width - 20, line_y)], fill=0, width=2)
        else:
            # Fallback if image isn't available
            title_text = "Chuck Norris Fact"
            bbox = draw.textbbox((0, 0), title_text, font=self.title_font)
            title_width = bbox[2] - bbox[0]
            
            x = (self.width - title_width) // 2
            y = 40
            draw.text((x, y), title_text, font=self.title_font, fill=0)
            
            line_y = y + bbox[3] - bbox[1] + 20
            draw.line([(20, line_y), (self.width - 20, line_y)], fill=0, width=2)

    def _draw_fact(self, draw: ImageDraw, data: Dict[str, Any]):
        """Draw the main fact text with proper boundaries and overflow handling"""
        fact_text = data.get('fact', 'No fact available')
        
        # Define the content area dimensions with proper margins
        header_height = 180 if self.cached_chuck_image else 120
        footer_height = 80
        content_width = self.width - 80  # 40px padding on each side
        content_height = self.height - header_height - footer_height
        
        # Starting font size and minimum size
        max_font_size = 48
        min_font_size = 24
        optimal_font_size = max_font_size
        
        # Find the optimal font size that fits within boundaries
        while optimal_font_size >= min_font_size:
            try:
                test_font = ImageFont.truetype('arial.ttf', optimal_font_size)
            except:
                test_font = ImageFont.load_default()
            
            # Calculate wrap width based on average character width
            avg_char_width = test_font.getlength('x')  # Use 'x' for average width
            chars_per_line = int((content_width - 40) / avg_char_width)  # Add extra padding
            
            # Wrap text
            wrapped_text = textwrap.fill(fact_text, width=chars_per_line)
            
            # Calculate wrapped text dimensions
            bbox = draw.multiline_textbbox((0, 0), wrapped_text, font=test_font)
            text_width = bbox[2] - bbox[0]
            text_height = bbox[3] - bbox[1]
            
            # Check if text fits within content area with padding
            if text_width <= content_width - 40 and text_height <= content_height - 40:
                break
                
            optimal_font_size -= 2
        
        # Use minimum font size if we couldn't fit the text
        if optimal_font_size < min_font_size:
            optimal_font_size = min_font_size
        
        # Create final font
        try:
            final_font = ImageFont.truetype('arial.ttf', optimal_font_size)
        except:
            final_font = ImageFont.load_default()
        
        # Final text wrapping with proper width calculation
        avg_char_width = final_font.getlength('x')
        chars_per_line = int((content_width - 40) / avg_char_width)
        wrapped_text = textwrap.fill(fact_text, width=chars_per_line)
        
        # Calculate text dimensions for centering
        bbox = draw.multiline_textbbox((0, 0), wrapped_text, font=final_font)
        final_width = bbox[2] - bbox[0]
        final_height = bbox[3] - bbox[1]
        
        # Center the text with proper margins
        x = (self.width - final_width) // 2
        y = header_height + (content_height - final_height) // 2
        
        # Draw text with proper line spacing
        draw.multiline_text(
            (x, y),
            wrapped_text,
            font=final_font,
            fill=0,
            align='center',
            spacing=int(optimal_font_size * 0.3)  # Adjusted line spacing
        )

    def _draw_footer(self, draw: ImageDraw, data: Dict[str, Any]):
        """Draw the footer with fact ID and timestamp"""
        # Draw fact ID
        fact_id = f"Fact ID: {data.get('fact_id', 'Unknown')}"
        
        # Format timestamp
        timestamp = data.get('timestamp', 'Unknown')
        if isinstance(timestamp, str):
            try:
                dt = datetime.fromisoformat(timestamp.replace('Z', '+00:00'))
                timestamp = dt.strftime('%Y-%m-%d %H:%M:%S UTC')
            except ValueError:
                pass
        
        # Draw footer line
        footer_y = self.height - 60
        draw.line([(20, footer_y), (self.width - 20, footer_y)], fill=0, width=1)
        
        # Draw footer text
        draw.text(
            (20, footer_y + 10),
            fact_id,
            font=self.meta_font,
            fill=0
        )
        
        timestamp_bbox = draw.textbbox((0, 0), timestamp, font=self.meta_font)
        timestamp_width = timestamp_bbox[2] - timestamp_bbox[0]
        draw.text(
            (self.width - timestamp_width - 20, footer_y + 10),
            timestamp,
            font=self.meta_font,
            fill=0
        )

    def create_error_display(self, error_message: str) -> bytes:
        """Create an error display"""
        image = Image.new('1', (self.width, self.height), 1)
        draw = ImageDraw.Draw(image)
        
        # Draw error header
        header_text = 'Error'
        bbox = draw.textbbox((0, 0), header_text, font=self.title_font)
        header_width = bbox[2] - bbox[0]
        
        x = (self.width - header_width) // 2
        y = 40
        draw.text((x, y), header_text, font=self.title_font, fill=0)
        
        # Draw error message
        wrapped_error = textwrap.fill(error_message, width=40)
        bbox = draw.multiline_textbbox((0, 0), wrapped_error, font=self.fact_font)
        error_width = bbox[2] - bbox[0]
        
        x = (self.width - error_width) // 2
        y = (self.height - bbox[3] + bbox[1]) // 2
        
        draw.multiline_text(
            (x, y),
            wrapped_error,
            font=self.fact_font,
            fill=0,
            align='center',
            spacing=10
        )
        
        buffer = io.BytesIO()
        image.save(buffer, format='BMP')
        return buffer.getvalue()

================
File: src/utils/__init__.py
================
from .formatters import (
    format_timestamp,
    format_error_response,
    format_data_response
)

from .validators import (
    validate_timestamp,
    validate_data,
    sanitize_string
)

__all__ = [
    # Formatters
    'format_timestamp',
    'format_error_response',
    'format_data_response',
    
    # Validators
    'validate_timestamp',
    'validate_data',
    'sanitize_string'
]

================
File: src/utils/formatters.py
================
from datetime import datetime, UTC
from typing import Optional, Dict, Any
from flask import jsonify

def format_timestamp(timestamp: str) -> str:
    '''Format timestamp for display.
    
    Args:
        timestamp: ISO format timestamp or UTC timestamp string
        
    Returns:
        Formatted timestamp string in 'YYYY-MM-DD HH:MM UTC' format
    '''
    try:
        # Handle ISO format
        if 'T' in timestamp:
            dt = datetime.fromisoformat(timestamp.replace('Z', '+00:00'))
        # Handle 'YYYY-MM-DD HH:MM:SS UTC' format
        else:
            dt = datetime.strptime(timestamp.replace(' UTC', ''), '%Y-%m-%d %H:%M:%S')
            dt = dt.replace(tzinfo=UTC)
            
        return dt.strftime('%Y-%m-%d %H:%M UTC')
    except (ValueError, AttributeError):
        return timestamp

def format_error_response(error_message: str, status_code: int = 500) -> Dict[str, Any]:
    '''Format error response for API endpoints.
    
    Args:
        error_message: Error message to return
        status_code: HTTP status code (default 500)
        
    Returns:
        Error response dictionary
    '''
    return jsonify({
        'error': error_message,
        'timestamp': datetime.now(UTC).isoformat(),
        'status': 'error'
    }), status_code

def format_data_response(data: Dict[str, Any]) -> Dict[str, Any]:
    '''Format successful data response.
    
    Args:
        data: Data to return
        
    Returns:
        Formatted response dictionary
    '''
    return {
        'data': data,
        'timestamp': datetime.now(UTC).isoformat(),
        'status': 'success'
    }

================
File: src/utils/validators.py
================
from datetime import datetime
from typing import Optional, Dict, Any, Tuple
import re

def validate_timestamp(timestamp: str) -> bool:
    '''Validate timestamp format.
    
    Args:
        timestamp: Timestamp string
        
    Returns:
        True if valid, False otherwise
    '''
    # Try ISO format
    try:
        datetime.fromisoformat(timestamp.replace('Z', '+00:00'))
        return True
    except ValueError:
        pass
    
    # Try 'YYYY-MM-DD HH:MM:SS UTC' format
    try:
        datetime.strptime(timestamp.replace(' UTC', ''), '%Y-%m-%d %H:%M:%S')
        return True
    except ValueError:
        return False

def validate_data(data: Dict[str, Any]) -> Tuple[bool, Optional[str]]:
    '''Validate data dictionary structure.
    
    Args:
        data: Dictionary containing data to validate
        
    Returns:
        Tuple of (is_valid, error_message)
    '''
    # Add your data validation logic here
    # Example:
    required_fields = ['timestamp']
    
    # Check required fields
    for field in required_fields:
        if field not in data:
            return False, f'Missing required field: {field}'
            
    # Validate timestamp if present
    if 'timestamp' in data and not validate_timestamp(data['timestamp']):
        return False, 'Invalid timestamp format'
    
    return True, None

def sanitize_string(input_str: str, max_length: int = 100) -> str:
    '''Sanitize string input for display.
    
    Args:
        input_str: String to sanitize
        max_length: Maximum allowed length
        
    Returns:
        Sanitized string
    '''
    if not isinstance(input_str, str):
        return ''
    
    # Remove any non-printable characters
    clean_str = ''.join(char for char in input_str if char.isprintable())
    
    # Remove any potential HTML/script tags
    clean_str = re.sub(r'<[^>]*>', '', clean_str)
    
    # Truncate to max length
    return clean_str[:max_length]

================
File: tests/test_display.py
================
from datetime import datetime, UTC
import pytest
from src.services.display import DisplayGenerator
from src.services.api_service import APIService

def test_display_generator_initialization():
    '''Test DisplayGenerator initialization'''
    display = DisplayGenerator(800, 480)
    assert display.width == 800
    assert display.height == 480
    assert display.font is not None

def test_error_display():
    '''Test error display generation'''
    display = DisplayGenerator(800, 480)
    error_msg = 'Test error message'
    image_data = display.create_error_display(error_msg)
    assert image_data is not None
    assert len(image_data) > 0

def test_api_service():
    '''Test APIService basic functionality'''
    service = APIService()
    data = service.get_data()
    assert isinstance(data, dict)
    assert 'timestamp' in data
    assert 'status' in data

def test_display_creation():
    '''Test display creation with mock data'''
    display = DisplayGenerator(800, 480)
    test_data = {
        'timestamp': datetime.now(UTC).isoformat(),
        'status': 'ok',
        'test_value': 123
    }
    image_data = display.create_display(test_data)
    assert image_data is not None
    assert len(image_data) > 0
